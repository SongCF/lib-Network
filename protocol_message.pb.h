// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol_message.proto

#ifndef PROTOBUF_protocol_5fmessage_2eproto__INCLUDED
#define PROTOBUF_protocol_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace PetOnline {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protocol_5fmessage_2eproto();
void protobuf_AssignDesc_protocol_5fmessage_2eproto();
void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

class CoordinateInfo;
class UserInfo;
class ItemInfo;
class ExchangeInfo;
class RegistReq;
class RegistRsp;
class LoginReq;
class LoginRsp;
class ExchangeReq;
class ExchangeRsp;

// ===================================================================

class CoordinateInfo : public ::google::protobuf::MessageLite {
 public:
  CoordinateInfo();
  virtual ~CoordinateInfo();

  CoordinateInfo(const CoordinateInfo& from);

  inline CoordinateInfo& operator=(const CoordinateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CoordinateInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CoordinateInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CoordinateInfo* other);

  // implements Message ----------------------------------------------

  CoordinateInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CoordinateInfo& from);
  void MergeFrom(const CoordinateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline float latitude() const;
  inline void set_latitude(float value);

  // required float longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline float longitude() const;
  inline void set_longitude(float value);

  // @@protoc_insertion_point(class_scope:PetOnline.CoordinateInfo)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();

  float latitude_;
  float longitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static CoordinateInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::MessageLite {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional .PetOnline.CoordinateInfo coordinate = 2;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 2;
  inline const ::PetOnline::CoordinateInfo& coordinate() const;
  inline ::PetOnline::CoordinateInfo* mutable_coordinate();
  inline ::PetOnline::CoordinateInfo* release_coordinate();
  inline void set_allocated_coordinate(::PetOnline::CoordinateInfo* coordinate);

  // @@protoc_insertion_point(class_scope:PetOnline.UserInfo)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_coordinate();
  inline void clear_has_coordinate();

  ::std::string* nickname_;
  ::PetOnline::CoordinateInfo* coordinate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ItemInfo : public ::google::protobuf::MessageLite {
 public:
  ItemInfo();
  virtual ~ItemInfo();

  ItemInfo(const ItemInfo& from);

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemInfo* other);

  // implements Message ----------------------------------------------

  ItemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemInfo& from);
  void MergeFrom(const ItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // optional int32 item_count = 2;
  inline bool has_item_count() const;
  inline void clear_item_count();
  static const int kItemCountFieldNumber = 2;
  inline ::google::protobuf::int32 item_count() const;
  inline void set_item_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PetOnline.ItemInfo)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_count();
  inline void clear_has_item_count();

  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 item_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeInfo : public ::google::protobuf::MessageLite {
 public:
  ExchangeInfo();
  virtual ~ExchangeInfo();

  ExchangeInfo(const ExchangeInfo& from);

  inline ExchangeInfo& operator=(const ExchangeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExchangeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeInfo* other);

  // implements Message ----------------------------------------------

  ExchangeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeInfo& from);
  void MergeFrom(const ExchangeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_exchanged = 1;
  inline bool has_is_exchanged() const;
  inline void clear_is_exchanged();
  static const int kIsExchangedFieldNumber = 1;
  inline bool is_exchanged() const;
  inline void set_is_exchanged(bool value);

  // optional .PetOnline.ItemInfo onhand_item = 2;
  inline bool has_onhand_item() const;
  inline void clear_onhand_item();
  static const int kOnhandItemFieldNumber = 2;
  inline const ::PetOnline::ItemInfo& onhand_item() const;
  inline ::PetOnline::ItemInfo* mutable_onhand_item();
  inline ::PetOnline::ItemInfo* release_onhand_item();
  inline void set_allocated_onhand_item(::PetOnline::ItemInfo* onhand_item);

  // optional .PetOnline.ItemInfo need_item = 3;
  inline bool has_need_item() const;
  inline void clear_need_item();
  static const int kNeedItemFieldNumber = 3;
  inline const ::PetOnline::ItemInfo& need_item() const;
  inline ::PetOnline::ItemInfo* mutable_need_item();
  inline ::PetOnline::ItemInfo* release_need_item();
  inline void set_allocated_need_item(::PetOnline::ItemInfo* need_item);

  // optional uint32 ex_time = 4;
  inline bool has_ex_time() const;
  inline void clear_ex_time();
  static const int kExTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 ex_time() const;
  inline void set_ex_time(::google::protobuf::uint32 value);

  // optional .PetOnline.UserInfo exchanged_user = 5;
  inline bool has_exchanged_user() const;
  inline void clear_exchanged_user();
  static const int kExchangedUserFieldNumber = 5;
  inline const ::PetOnline::UserInfo& exchanged_user() const;
  inline ::PetOnline::UserInfo* mutable_exchanged_user();
  inline ::PetOnline::UserInfo* release_exchanged_user();
  inline void set_allocated_exchanged_user(::PetOnline::UserInfo* exchanged_user);

  // @@protoc_insertion_point(class_scope:PetOnline.ExchangeInfo)
 private:
  inline void set_has_is_exchanged();
  inline void clear_has_is_exchanged();
  inline void set_has_onhand_item();
  inline void clear_has_onhand_item();
  inline void set_has_need_item();
  inline void clear_has_need_item();
  inline void set_has_ex_time();
  inline void clear_has_ex_time();
  inline void set_has_exchanged_user();
  inline void clear_has_exchanged_user();

  ::PetOnline::ItemInfo* onhand_item_;
  bool is_exchanged_;
  ::google::protobuf::uint32 ex_time_;
  ::PetOnline::ItemInfo* need_item_;
  ::PetOnline::UserInfo* exchanged_user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ExchangeInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegistReq : public ::google::protobuf::MessageLite {
 public:
  RegistReq();
  virtual ~RegistReq();

  RegistReq(const RegistReq& from);

  inline RegistReq& operator=(const RegistReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistReq* other);

  // implements Message ----------------------------------------------

  RegistReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistReq& from);
  void MergeFrom(const RegistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:PetOnline.RegistReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string* account_;
  ::std::string* passwd_;
  ::std::string* nickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RegistReq* default_instance_;
};
// -------------------------------------------------------------------

class RegistRsp : public ::google::protobuf::MessageLite {
 public:
  RegistRsp();
  virtual ~RegistRsp();

  RegistRsp(const RegistRsp& from);

  inline RegistRsp& operator=(const RegistRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistRsp* other);

  // implements Message ----------------------------------------------

  RegistRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistRsp& from);
  void MergeFrom(const RegistRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // optional int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PetOnline.RegistRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::int32 rsp_code_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RegistRsp* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::MessageLite {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // optional .PetOnline.CoordinateInfo coordinate = 2;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 2;
  inline const ::PetOnline::CoordinateInfo& coordinate() const;
  inline ::PetOnline::CoordinateInfo* mutable_coordinate();
  inline ::PetOnline::CoordinateInfo* release_coordinate();
  inline void set_allocated_coordinate(::PetOnline::CoordinateInfo* coordinate);

  // @@protoc_insertion_point(class_scope:PetOnline.LoginReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_coordinate();
  inline void clear_has_coordinate();

  ::PetOnline::CoordinateInfo* coordinate_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginRsp : public ::google::protobuf::MessageLite {
 public:
  LoginRsp();
  virtual ~LoginRsp();

  LoginRsp(const LoginRsp& from);

  inline LoginRsp& operator=(const LoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRsp* other);

  // implements Message ----------------------------------------------

  LoginRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRsp& from);
  void MergeFrom(const LoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .PetOnline.ExchangeInfo exchanged = 2;
  inline int exchanged_size() const;
  inline void clear_exchanged();
  static const int kExchangedFieldNumber = 2;
  inline const ::PetOnline::ExchangeInfo& exchanged(int index) const;
  inline ::PetOnline::ExchangeInfo* mutable_exchanged(int index);
  inline ::PetOnline::ExchangeInfo* add_exchanged();
  inline const ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >&
      exchanged() const;
  inline ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >*
      mutable_exchanged();

  // repeated .PetOnline.ExchangeInfo unshelve = 3;
  inline int unshelve_size() const;
  inline void clear_unshelve();
  static const int kUnshelveFieldNumber = 3;
  inline const ::PetOnline::ExchangeInfo& unshelve(int index) const;
  inline ::PetOnline::ExchangeInfo* mutable_unshelve(int index);
  inline ::PetOnline::ExchangeInfo* add_unshelve();
  inline const ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >&
      unshelve() const;
  inline ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >*
      mutable_unshelve();

  // @@protoc_insertion_point(class_scope:PetOnline.LoginRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo > exchanged_;
  ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo > unshelve_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeReq : public ::google::protobuf::MessageLite {
 public:
  ExchangeReq();
  virtual ~ExchangeReq();

  ExchangeReq(const ExchangeReq& from);

  inline ExchangeReq& operator=(const ExchangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExchangeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeReq* other);

  // implements Message ----------------------------------------------

  ExchangeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeReq& from);
  void MergeFrom(const ExchangeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // optional .PetOnline.ItemInfo onhand_item = 2;
  inline bool has_onhand_item() const;
  inline void clear_onhand_item();
  static const int kOnhandItemFieldNumber = 2;
  inline const ::PetOnline::ItemInfo& onhand_item() const;
  inline ::PetOnline::ItemInfo* mutable_onhand_item();
  inline ::PetOnline::ItemInfo* release_onhand_item();
  inline void set_allocated_onhand_item(::PetOnline::ItemInfo* onhand_item);

  // optional .PetOnline.ItemInfo need_item = 3;
  inline bool has_need_item() const;
  inline void clear_need_item();
  static const int kNeedItemFieldNumber = 3;
  inline const ::PetOnline::ItemInfo& need_item() const;
  inline ::PetOnline::ItemInfo* mutable_need_item();
  inline ::PetOnline::ItemInfo* release_need_item();
  inline void set_allocated_need_item(::PetOnline::ItemInfo* need_item);

  // @@protoc_insertion_point(class_scope:PetOnline.ExchangeReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_onhand_item();
  inline void clear_has_onhand_item();
  inline void set_has_need_item();
  inline void clear_has_need_item();

  ::PetOnline::ItemInfo* onhand_item_;
  ::PetOnline::ItemInfo* need_item_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ExchangeReq* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeRsp : public ::google::protobuf::MessageLite {
 public:
  ExchangeRsp();
  virtual ~ExchangeRsp();

  ExchangeRsp(const ExchangeRsp& from);

  inline ExchangeRsp& operator=(const ExchangeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExchangeRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExchangeRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExchangeRsp* other);

  // implements Message ----------------------------------------------

  ExchangeRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExchangeRsp& from);
  void MergeFrom(const ExchangeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // optional .PetOnline.ExchangeInfo ex_info = 2;
  inline bool has_ex_info() const;
  inline void clear_ex_info();
  static const int kExInfoFieldNumber = 2;
  inline const ::PetOnline::ExchangeInfo& ex_info() const;
  inline ::PetOnline::ExchangeInfo* mutable_ex_info();
  inline ::PetOnline::ExchangeInfo* release_ex_info();
  inline void set_allocated_ex_info(::PetOnline::ExchangeInfo* ex_info);

  // @@protoc_insertion_point(class_scope:PetOnline.ExchangeRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_ex_info();
  inline void clear_has_ex_info();

  ::PetOnline::ExchangeInfo* ex_info_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ExchangeRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// CoordinateInfo

// required float latitude = 1;
inline bool CoordinateInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordinateInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordinateInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordinateInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float CoordinateInfo::latitude() const {
  return latitude_;
}
inline void CoordinateInfo::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// required float longitude = 2;
inline bool CoordinateInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoordinateInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoordinateInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoordinateInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float CoordinateInfo::longitude() const {
  return longitude_;
}
inline void CoordinateInfo::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// required string nickname = 1;
inline bool UserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfo::nickname() const {
  return *nickname_;
}
inline void UserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* UserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PetOnline.CoordinateInfo coordinate = 2;
inline bool UserInfo::has_coordinate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_coordinate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_coordinate() {
  if (coordinate_ != NULL) coordinate_->::PetOnline::CoordinateInfo::Clear();
  clear_has_coordinate();
}
inline const ::PetOnline::CoordinateInfo& UserInfo::coordinate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return coordinate_ != NULL ? *coordinate_ : *default_instance().coordinate_;
#else
  return coordinate_ != NULL ? *coordinate_ : *default_instance_->coordinate_;
#endif
}
inline ::PetOnline::CoordinateInfo* UserInfo::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) coordinate_ = new ::PetOnline::CoordinateInfo;
  return coordinate_;
}
inline ::PetOnline::CoordinateInfo* UserInfo::release_coordinate() {
  clear_has_coordinate();
  ::PetOnline::CoordinateInfo* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_coordinate(::PetOnline::CoordinateInfo* coordinate) {
  delete coordinate_;
  coordinate_ = coordinate;
  if (coordinate) {
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
}

// -------------------------------------------------------------------

// ItemInfo

// required int32 item_id = 1;
inline bool ItemInfo::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemInfo::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemInfo::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemInfo::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 ItemInfo::item_id() const {
  return item_id_;
}
inline void ItemInfo::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional int32 item_count = 2;
inline bool ItemInfo::has_item_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemInfo::set_has_item_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemInfo::clear_has_item_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemInfo::clear_item_count() {
  item_count_ = 0;
  clear_has_item_count();
}
inline ::google::protobuf::int32 ItemInfo::item_count() const {
  return item_count_;
}
inline void ItemInfo::set_item_count(::google::protobuf::int32 value) {
  set_has_item_count();
  item_count_ = value;
}

// -------------------------------------------------------------------

// ExchangeInfo

// required bool is_exchanged = 1;
inline bool ExchangeInfo::has_is_exchanged() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeInfo::set_has_is_exchanged() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeInfo::clear_has_is_exchanged() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeInfo::clear_is_exchanged() {
  is_exchanged_ = false;
  clear_has_is_exchanged();
}
inline bool ExchangeInfo::is_exchanged() const {
  return is_exchanged_;
}
inline void ExchangeInfo::set_is_exchanged(bool value) {
  set_has_is_exchanged();
  is_exchanged_ = value;
}

// optional .PetOnline.ItemInfo onhand_item = 2;
inline bool ExchangeInfo::has_onhand_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeInfo::set_has_onhand_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeInfo::clear_has_onhand_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeInfo::clear_onhand_item() {
  if (onhand_item_ != NULL) onhand_item_->::PetOnline::ItemInfo::Clear();
  clear_has_onhand_item();
}
inline const ::PetOnline::ItemInfo& ExchangeInfo::onhand_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return onhand_item_ != NULL ? *onhand_item_ : *default_instance().onhand_item_;
#else
  return onhand_item_ != NULL ? *onhand_item_ : *default_instance_->onhand_item_;
#endif
}
inline ::PetOnline::ItemInfo* ExchangeInfo::mutable_onhand_item() {
  set_has_onhand_item();
  if (onhand_item_ == NULL) onhand_item_ = new ::PetOnline::ItemInfo;
  return onhand_item_;
}
inline ::PetOnline::ItemInfo* ExchangeInfo::release_onhand_item() {
  clear_has_onhand_item();
  ::PetOnline::ItemInfo* temp = onhand_item_;
  onhand_item_ = NULL;
  return temp;
}
inline void ExchangeInfo::set_allocated_onhand_item(::PetOnline::ItemInfo* onhand_item) {
  delete onhand_item_;
  onhand_item_ = onhand_item;
  if (onhand_item) {
    set_has_onhand_item();
  } else {
    clear_has_onhand_item();
  }
}

// optional .PetOnline.ItemInfo need_item = 3;
inline bool ExchangeInfo::has_need_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeInfo::set_has_need_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeInfo::clear_has_need_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeInfo::clear_need_item() {
  if (need_item_ != NULL) need_item_->::PetOnline::ItemInfo::Clear();
  clear_has_need_item();
}
inline const ::PetOnline::ItemInfo& ExchangeInfo::need_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return need_item_ != NULL ? *need_item_ : *default_instance().need_item_;
#else
  return need_item_ != NULL ? *need_item_ : *default_instance_->need_item_;
#endif
}
inline ::PetOnline::ItemInfo* ExchangeInfo::mutable_need_item() {
  set_has_need_item();
  if (need_item_ == NULL) need_item_ = new ::PetOnline::ItemInfo;
  return need_item_;
}
inline ::PetOnline::ItemInfo* ExchangeInfo::release_need_item() {
  clear_has_need_item();
  ::PetOnline::ItemInfo* temp = need_item_;
  need_item_ = NULL;
  return temp;
}
inline void ExchangeInfo::set_allocated_need_item(::PetOnline::ItemInfo* need_item) {
  delete need_item_;
  need_item_ = need_item;
  if (need_item) {
    set_has_need_item();
  } else {
    clear_has_need_item();
  }
}

// optional uint32 ex_time = 4;
inline bool ExchangeInfo::has_ex_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExchangeInfo::set_has_ex_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExchangeInfo::clear_has_ex_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExchangeInfo::clear_ex_time() {
  ex_time_ = 0u;
  clear_has_ex_time();
}
inline ::google::protobuf::uint32 ExchangeInfo::ex_time() const {
  return ex_time_;
}
inline void ExchangeInfo::set_ex_time(::google::protobuf::uint32 value) {
  set_has_ex_time();
  ex_time_ = value;
}

// optional .PetOnline.UserInfo exchanged_user = 5;
inline bool ExchangeInfo::has_exchanged_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExchangeInfo::set_has_exchanged_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExchangeInfo::clear_has_exchanged_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExchangeInfo::clear_exchanged_user() {
  if (exchanged_user_ != NULL) exchanged_user_->::PetOnline::UserInfo::Clear();
  clear_has_exchanged_user();
}
inline const ::PetOnline::UserInfo& ExchangeInfo::exchanged_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return exchanged_user_ != NULL ? *exchanged_user_ : *default_instance().exchanged_user_;
#else
  return exchanged_user_ != NULL ? *exchanged_user_ : *default_instance_->exchanged_user_;
#endif
}
inline ::PetOnline::UserInfo* ExchangeInfo::mutable_exchanged_user() {
  set_has_exchanged_user();
  if (exchanged_user_ == NULL) exchanged_user_ = new ::PetOnline::UserInfo;
  return exchanged_user_;
}
inline ::PetOnline::UserInfo* ExchangeInfo::release_exchanged_user() {
  clear_has_exchanged_user();
  ::PetOnline::UserInfo* temp = exchanged_user_;
  exchanged_user_ = NULL;
  return temp;
}
inline void ExchangeInfo::set_allocated_exchanged_user(::PetOnline::UserInfo* exchanged_user) {
  delete exchanged_user_;
  exchanged_user_ = exchanged_user;
  if (exchanged_user) {
    set_has_exchanged_user();
  } else {
    clear_has_exchanged_user();
  }
}

// -------------------------------------------------------------------

// RegistReq

// required string account = 1;
inline bool RegistReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RegistReq::account() const {
  return *account_;
}
inline void RegistReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RegistReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RegistReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RegistReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string passwd = 2;
inline bool RegistReq::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistReq::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistReq::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistReq::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& RegistReq::passwd() const {
  return *passwd_;
}
inline void RegistReq::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void RegistReq::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void RegistReq::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* RegistReq::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 3;
inline bool RegistReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RegistReq::nickname() const {
  return *nickname_;
}
inline void RegistReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegistReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegistReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* RegistReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegistRsp

// required int32 rsp_code = 1;
inline bool RegistRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 RegistRsp::rsp_code() const {
  return rsp_code_;
}
inline void RegistRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// optional int32 user_id = 2;
inline bool RegistRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistRsp::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 RegistRsp::user_id() const {
  return user_id_;
}
inline void RegistRsp::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// LoginReq

// required int32 user_id = 1;
inline bool LoginReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 LoginReq::user_id() const {
  return user_id_;
}
inline void LoginReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional .PetOnline.CoordinateInfo coordinate = 2;
inline bool LoginReq::has_coordinate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_coordinate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_coordinate() {
  if (coordinate_ != NULL) coordinate_->::PetOnline::CoordinateInfo::Clear();
  clear_has_coordinate();
}
inline const ::PetOnline::CoordinateInfo& LoginReq::coordinate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return coordinate_ != NULL ? *coordinate_ : *default_instance().coordinate_;
#else
  return coordinate_ != NULL ? *coordinate_ : *default_instance_->coordinate_;
#endif
}
inline ::PetOnline::CoordinateInfo* LoginReq::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) coordinate_ = new ::PetOnline::CoordinateInfo;
  return coordinate_;
}
inline ::PetOnline::CoordinateInfo* LoginReq::release_coordinate() {
  clear_has_coordinate();
  ::PetOnline::CoordinateInfo* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline void LoginReq::set_allocated_coordinate(::PetOnline::CoordinateInfo* coordinate) {
  delete coordinate_;
  coordinate_ = coordinate;
  if (coordinate) {
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
}

// -------------------------------------------------------------------

// LoginRsp

// required int32 rsp_code = 1;
inline bool LoginRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 LoginRsp::rsp_code() const {
  return rsp_code_;
}
inline void LoginRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .PetOnline.ExchangeInfo exchanged = 2;
inline int LoginRsp::exchanged_size() const {
  return exchanged_.size();
}
inline void LoginRsp::clear_exchanged() {
  exchanged_.Clear();
}
inline const ::PetOnline::ExchangeInfo& LoginRsp::exchanged(int index) const {
  return exchanged_.Get(index);
}
inline ::PetOnline::ExchangeInfo* LoginRsp::mutable_exchanged(int index) {
  return exchanged_.Mutable(index);
}
inline ::PetOnline::ExchangeInfo* LoginRsp::add_exchanged() {
  return exchanged_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >&
LoginRsp::exchanged() const {
  return exchanged_;
}
inline ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >*
LoginRsp::mutable_exchanged() {
  return &exchanged_;
}

// repeated .PetOnline.ExchangeInfo unshelve = 3;
inline int LoginRsp::unshelve_size() const {
  return unshelve_.size();
}
inline void LoginRsp::clear_unshelve() {
  unshelve_.Clear();
}
inline const ::PetOnline::ExchangeInfo& LoginRsp::unshelve(int index) const {
  return unshelve_.Get(index);
}
inline ::PetOnline::ExchangeInfo* LoginRsp::mutable_unshelve(int index) {
  return unshelve_.Mutable(index);
}
inline ::PetOnline::ExchangeInfo* LoginRsp::add_unshelve() {
  return unshelve_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >&
LoginRsp::unshelve() const {
  return unshelve_;
}
inline ::google::protobuf::RepeatedPtrField< ::PetOnline::ExchangeInfo >*
LoginRsp::mutable_unshelve() {
  return &unshelve_;
}

// -------------------------------------------------------------------

// ExchangeReq

// required int32 user_id = 1;
inline bool ExchangeReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 ExchangeReq::user_id() const {
  return user_id_;
}
inline void ExchangeReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional .PetOnline.ItemInfo onhand_item = 2;
inline bool ExchangeReq::has_onhand_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeReq::set_has_onhand_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeReq::clear_has_onhand_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeReq::clear_onhand_item() {
  if (onhand_item_ != NULL) onhand_item_->::PetOnline::ItemInfo::Clear();
  clear_has_onhand_item();
}
inline const ::PetOnline::ItemInfo& ExchangeReq::onhand_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return onhand_item_ != NULL ? *onhand_item_ : *default_instance().onhand_item_;
#else
  return onhand_item_ != NULL ? *onhand_item_ : *default_instance_->onhand_item_;
#endif
}
inline ::PetOnline::ItemInfo* ExchangeReq::mutable_onhand_item() {
  set_has_onhand_item();
  if (onhand_item_ == NULL) onhand_item_ = new ::PetOnline::ItemInfo;
  return onhand_item_;
}
inline ::PetOnline::ItemInfo* ExchangeReq::release_onhand_item() {
  clear_has_onhand_item();
  ::PetOnline::ItemInfo* temp = onhand_item_;
  onhand_item_ = NULL;
  return temp;
}
inline void ExchangeReq::set_allocated_onhand_item(::PetOnline::ItemInfo* onhand_item) {
  delete onhand_item_;
  onhand_item_ = onhand_item;
  if (onhand_item) {
    set_has_onhand_item();
  } else {
    clear_has_onhand_item();
  }
}

// optional .PetOnline.ItemInfo need_item = 3;
inline bool ExchangeReq::has_need_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeReq::set_has_need_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeReq::clear_has_need_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeReq::clear_need_item() {
  if (need_item_ != NULL) need_item_->::PetOnline::ItemInfo::Clear();
  clear_has_need_item();
}
inline const ::PetOnline::ItemInfo& ExchangeReq::need_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return need_item_ != NULL ? *need_item_ : *default_instance().need_item_;
#else
  return need_item_ != NULL ? *need_item_ : *default_instance_->need_item_;
#endif
}
inline ::PetOnline::ItemInfo* ExchangeReq::mutable_need_item() {
  set_has_need_item();
  if (need_item_ == NULL) need_item_ = new ::PetOnline::ItemInfo;
  return need_item_;
}
inline ::PetOnline::ItemInfo* ExchangeReq::release_need_item() {
  clear_has_need_item();
  ::PetOnline::ItemInfo* temp = need_item_;
  need_item_ = NULL;
  return temp;
}
inline void ExchangeReq::set_allocated_need_item(::PetOnline::ItemInfo* need_item) {
  delete need_item_;
  need_item_ = need_item;
  if (need_item) {
    set_has_need_item();
  } else {
    clear_has_need_item();
  }
}

// -------------------------------------------------------------------

// ExchangeRsp

// required int32 rsp_code = 1;
inline bool ExchangeRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 ExchangeRsp::rsp_code() const {
  return rsp_code_;
}
inline void ExchangeRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// optional .PetOnline.ExchangeInfo ex_info = 2;
inline bool ExchangeRsp::has_ex_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeRsp::set_has_ex_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeRsp::clear_has_ex_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeRsp::clear_ex_info() {
  if (ex_info_ != NULL) ex_info_->::PetOnline::ExchangeInfo::Clear();
  clear_has_ex_info();
}
inline const ::PetOnline::ExchangeInfo& ExchangeRsp::ex_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ex_info_ != NULL ? *ex_info_ : *default_instance().ex_info_;
#else
  return ex_info_ != NULL ? *ex_info_ : *default_instance_->ex_info_;
#endif
}
inline ::PetOnline::ExchangeInfo* ExchangeRsp::mutable_ex_info() {
  set_has_ex_info();
  if (ex_info_ == NULL) ex_info_ = new ::PetOnline::ExchangeInfo;
  return ex_info_;
}
inline ::PetOnline::ExchangeInfo* ExchangeRsp::release_ex_info() {
  clear_has_ex_info();
  ::PetOnline::ExchangeInfo* temp = ex_info_;
  ex_info_ = NULL;
  return temp;
}
inline void ExchangeRsp::set_allocated_ex_info(::PetOnline::ExchangeInfo* ex_info) {
  delete ex_info_;
  ex_info_ = ex_info;
  if (ex_info) {
    set_has_ex_info();
  } else {
    clear_has_ex_info();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PetOnline

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_5fmessage_2eproto__INCLUDED
